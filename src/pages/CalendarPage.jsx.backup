import React, { useState, useEffect, useCallback } from 'react';
import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import timeGridPlugin from '@fullcalendar/timegrid';
import interactionPlugin from '@fullcalendar/interaction';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { apiClient } from '../lib/api';
import { Calendar, Clock, Check, X, RotateCcw, AlertCircle } from 'lucide-react';
import { useHapticFeedback } from '../components/HapticFeedback';
import toast from 'react-hot-toast';

export default function CalendarPage() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { trigger } = useHapticFeedback();
  
  // URL params & localStorage
  let clinicId = searchParams.get('clinic_id') || localStorage.getItem('clinic_id');
  let userRowId = searchParams.get('user_row_id') || localStorage.getItem('user_row_id');

  // Core states
  const [events, setEvents] = useState([]);
  const [loading, setLoading] = useState(false);
  const [businessHours, setBusinessHours] = useState(null);
  const [clinicInfo, setClinicInfo] = useState(null);
  
  // Modal states
  const [modal, setModal] = useState({ type: null, data: null });

  // Redirect if missing params
  useEffect(() => {
    if (!clinicId || !userRowId) {
      navigate(`/booking${clinicId ? ('?clinic_id=' + clinicId) : ''}`);
    }
  }, [clinicId, userRowId, navigate]);

  // Fetch data
  useEffect(() => {
    if (!clinicId || !userRowId) return;
    
    const fetchData = async () => {
      setLoading(true);
      try {
        const [clinicRes, visitsRes] = await Promise.all([
          apiClient.getClinicInfo(clinicId),
          apiClient.getUserVisits(clinicId, userRowId)
        ]);
        
        setClinicInfo(clinicRes.data);
        setBusinessHours(clinicRes.data.business_hours);
        
        const appointments = (visitsRes.data || [])
          .filter(v => v.status === 'booked')
          .map(v => ({
            id: v.id,
            title: '● Appointment',
            start: new Date(v.book_time || v.visit_time),
            end: new Date((new Date(v.book_time || v.visit_time)).getTime() + 30 * 60 * 1000),
            backgroundColor: '#3B82F6',
            borderColor: '#3B82F6',
            textColor: 'white',
            userRowId: v.user_row_id
          }))
          .filter(e => e.start);
        
        setEvents(appointments);
      } catch (error) {
        console.error('Failed to fetch data:', error);
        toast.error('Failed to load calendar data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [clinicId, userRowId]);

  // Get available slots for date
  const getAvailableSlots = async (date) => {
    if (!businessHours) return [];
    
    const weekdays = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
    const dayConfig = businessHours[weekdays[date.getDay()]];
    if (!dayConfig || dayConfig.closed) return 'closed';
    
    const [startH, startM = 0] = dayConfig.open.split(':').map(Number);
    const [endH, endM = 0] = dayConfig.close.split(':').map(Number);
    const now = new Date();
    const maxDate = new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000);
    
    if (date > maxDate) return [];
    
    try {
      const dateStr = date.toISOString().split('T')[0];
      const result = await apiClient.getSlotAvailability(clinicId, dateStr);
      const slotAvailability = result.data || [];
      
      const slots = [];
      
      // Generate slots for business hours (every 30 minutes)
      for (let minutes = startH * 60 + startM; minutes < endH * 60 + endM; minutes += 30) {
        const hour = Math.floor(minutes / 60);
        const minute = minutes % 60;
        const slotTime = new Date(date);
        slotTime.setHours(hour, minute, 0, 0);
        
        // Skip past times - if today, must be at least next full hour after current time
        if (date.toDateString() === now.toDateString()) {
          const nextHour = new Date(now);
          nextHour.setHours(now.getHours() + 1, 0, 0, 0);
          if (slotTime < nextHour) continue;
        }
        
        const timeStr = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`;
        
        // Check how many bookings exist for this slot
        let bookingCount = 0;
        const slotData = slotAvailability.find(slot => slot.visit_time === timeStr);
        
        if (slotData) {
          // Count existing bookings for this time slot
          bookingCount = slotData.booking_count || 0;
        }
        
        // Slot is available if less than 2 people booked
        const isAvailable = bookingCount < 2;
        const isFull = bookingCount >= 2;
        
        slots.push({ 
          hour, 
          minute, 
          isAvailable, 
          isFull,
          bookingCount,
          timeStr 
        });
      }
      
      return slots;
    } catch (error) {
      console.warn('Slot availability query failed:', error);
      // If API fails, generate default slots based on business hours only
      const slots = [];
      for (let minutes = startH * 60 + startM; minutes < endH * 60 + endM; minutes += 30) {
        const hour = Math.floor(minutes / 60);
        const minute = minutes % 60;
        const slotTime = new Date(date);
        slotTime.setHours(hour, minute, 0, 0);
        
        if (date.toDateString() === now.toDateString()) {
          const nextHour = new Date(now);
          nextHour.setHours(now.getHours() + 1, 0, 0, 0);
          if (slotTime < nextHour) continue;
        }
        
        slots.push({ 
          hour, 
          minute, 
          isAvailable: true, 
          isFull: false,
          bookingCount: 0,
          timeStr: `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`
        });
      }
      return slots;
    }
  };

  // Handle date selection
  const handleDateSelect = useCallback(async (selectInfo) => {
    trigger('light');
    const date = selectInfo.start;
    const now = new Date();
    
    // Validate date constraints
    if (date < now.setHours(0, 0, 0, 0)) {
      toast.error('Cannot book appointments in the past');
      return;
    }
    
    const maxDate = new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000);
    if (date > maxDate) {
      toast.error('Can only book up to 14 days in advance');
      return;
    }
    
    // Check if user has appointment on this date
    const dateEvents = events.filter(e => 
      e.start.toDateString() === date.toDateString() && e.userRowId === userRowId
    );
    
    // If user already has appointment on this date, show reschedule/cancel options
    if (dateEvents.length > 0) {
      const existingEvent = dateEvents[0];
      const appointmentTime = formatTime(existingEvent.start.getHours(), existingEvent.start.getMinutes());
      
      setModal({ 
        type: 'reschedule', 
        data: { 
          eventId: existingEvent.id, 
          date, 
          currentTime: appointmentTime
        } 
      });
      return;
    }
    
    const slots = await getAvailableSlots(date);
    
    if (slots === 'closed') {
      toast.error('Clinic is closed on this day');
      return;
    }
    
    if (!Array.isArray(slots)) {
      toast.error('Unable to load available time slots');
      return;
    }
    
    // Include all slots but mark availability
    const availableSlots = slots.filter(s => s.isAvailable);
    if (availableSlots.length === 0) {
      toast.error('No available time slots');
      return;
    }
    
    // Check if user has appointment on other dates (for change functionality)
    const userHasOtherBooking = events.some(e => 
      e.start.toDateString() !== date.toDateString() && e.userRowId === userRowId
    );
    
    setModal({ 
      type: 'book', 
      data: { date, slots, userHasOtherBooking } 
    });
  }, [events, userRowId, trigger]);

  // Handle event click
  const handleEventClick = useCallback((clickInfo) => {
    trigger('medium');
    if (clickInfo.event.extendedProps.userRowId === userRowId) {
      setModal({ 
        type: 'cancel', 
        data: { eventId: clickInfo.event.id } 
      });
    }
  }, [userRowId, trigger]);

  // Book appointment
  const bookAppointment = async (hour, minute) => {
    try {
      trigger('success');
      const date = new Date(modal.data.date);
      date.setHours(hour, minute, 0, 0);
      
      // Validate user and check existing bookings
      const [, { data: existingBookings }] = await Promise.all([
        apiClient.validateUser(clinicId, userRowId),
        apiClient.getUserVisits(clinicId, userRowId)
      ]);
      
      const today = new Date(modal.data.date);
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
      
      const todayBookings = (existingBookings || []).filter(booking => {
        const bookingDate = new Date(booking.book_time);
        return booking.status === 'booked' && bookingDate >= today && bookingDate < tomorrow;
      });
      
      if (todayBookings.length > 0) {
        toast.error('You already have an appointment today');
        return;
      }
      
      // Create appointment
      await apiClient.createVisit({
        user_row_id: userRowId,
        clinic_id: clinicId,
        book_time: date.toISOString(),
        visit_time: date.toISOString(),
        status: 'booked',
        is_first: false,
      });
      
      // Update UI
      const newEvent = {
        id: Date.now(),
        title: '● Appointment',
        start: date,
        end: new Date(date.getTime() + 30 * 60 * 1000),
        backgroundColor: '#3B82F6',
        borderColor: '#3B82F6',
        textColor: 'white',
        userRowId
      };
      
      setEvents(prev => [...prev, newEvent]);
      setModal({ type: null, data: null });
      toast.success(`Appointment booked for ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
      
    } catch (error) {
      trigger('error');
      console.error('Booking failed:', error);
      toast.error('Booking failed. Please try again.');
    }
  };

  // Cancel appointment
  const cancelAppointment = async () => {
    try {
      trigger('warning');
      await apiClient.updateVisit(modal.data.eventId, { status: 'canceled' });
      setEvents(prev => prev.filter(e => e.id !== modal.data.eventId));
      setModal({ type: null, data: null });
      toast.success('Appointment cancelled');
    } catch (error) {
      trigger('error');
      console.error('Cancel failed:', error);
      toast.error('Failed to cancel appointment');
    }
  };

  // Change appointment
  const changeAppointment = async (hour, minute) => {
    try {
      trigger('success');
      const date = new Date(modal.data.date);
      date.setHours(hour, minute, 0, 0);
      
      // Get today's visits and cancel existing ones
      const { data: allVisits } = await apiClient.getUserVisits(clinicId, userRowId);
      const existingVisits = (allVisits || []).filter(visit => visit.status === 'booked');
      
      for (const visit of existingVisits) {
        await apiClient.updateVisit(visit.id, { status: 'canceled' });
      }
      
      // Create new appointment
      await apiClient.createVisit({
        user_row_id: userRowId,
        clinic_id: clinicId,
        book_time: date.toISOString(),
        visit_time: date.toISOString(),
        status: 'booked',
        is_first: false,
      });
      
      // Update UI
      const newEvent = {
        id: Date.now(),
        title: '● Appointment',
        start: date,
        end: new Date(date.getTime() + 30 * 60 * 1000),
        backgroundColor: '#3B82F6',
        borderColor: '#3B82F6',
        textColor: 'white',
        userRowId
      };
      
      setEvents(prev => [
        ...prev.filter(e => e.userRowId !== userRowId),
        newEvent
      ]);
      
      setModal({ type: null, data: null });
      toast.success(`Appointment changed to ${formatTime(hour, minute)}`);
      
    } catch (error) {
      trigger('error');
      console.error('Change failed:', error);
      toast.error('Failed to change appointment');
    }
  };

  const formatTime = (hour, minute = 0) => 
    `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;

  // Render modal content
  const renderModal = () => {
    if (!modal.type) return null;

    const commonModalProps = {
      className: "fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm p-4",
      onClick: (e) => {
        if (e.target === e.currentTarget) {
          setModal({ type: null, data: null });
        }
      }
    };

    if (modal.type === 'book') {
      const { date, slots, userHasOtherBooking } = modal.data;
      const amSlots = slots.filter(s => s.hour < 12);
      const pmSlots = slots.filter(s => s.hour >= 12);
      
      return (
        <div {...commonModalProps}>
          <div className="bg-white rounded-3xl shadow-2xl w-full max-w-lg overflow-hidden animate-scale-in">
            <div className="bg-gradient-to-r from-blue-600 to-indigo-600 px-8 py-6 text-white">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-xl font-bold mb-1">
                    {userHasOtherBooking ? 'Change Appointment' : 'Book Appointment'}
                  </h3>
                  <p className="text-blue-100">
                    {date.toLocaleDateString('en-US', { 
                      weekday: 'long', month: 'long', day: 'numeric'
                    })}
                  </p>
                  {userHasOtherBooking && (
                    <p className="text-xs text-blue-200 mt-1">
                      This will cancel your existing appointment
                    </p>
                  )}
                </div>
                <button
                  onClick={() => setModal({ type: null, data: null })}
                  className="w-10 h-10 rounded-full bg-white/10 hover:bg-white/20 flex items-center justify-center transition-colors"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
            </div>
            
            <div className="p-8">
              {[
                { label: 'Morning', slots: amSlots },
                { label: 'Afternoon', slots: pmSlots }
              ].map(({ label, slots }) => 
                slots.length > 0 && (
                  <div key={label} className="mb-6 last:mb-0">
                    <h4 className="text-sm font-semibold text-gray-600 mb-3">{label}</h4>
                    <div className="grid grid-cols-3 gap-3">
                      {slots.map(slot => {
                        const isClickable = slot.isAvailable;
                        const isFull = slot.isFull;
                        
                        return (
                          <button
                            key={`${slot.hour}:${slot.minute}`}
                            onClick={() => {
                              if (!isClickable) return;
                              if (userHasOtherBooking) {
                                changeAppointment(slot.hour, slot.minute);
                              } else {
                                bookAppointment(slot.hour, slot.minute);
                              }
                            }}
                            disabled={!isClickable}
                            className={`px-4 py-4 rounded-2xl border-2 transition-all duration-200 text-center font-medium ${
                              !isClickable
                                ? 'border-gray-200 bg-gray-100 text-gray-400 cursor-not-allowed'
                                : userHasOtherBooking 
                                  ? 'border-yellow-300 bg-yellow-50 text-yellow-700 hover:border-yellow-400 hover:bg-yellow-100' 
                                  : 'border-gray-200 text-gray-700 hover:border-blue-500 hover:bg-blue-50 hover:text-blue-700'
                            }`}
                          >
                            <div className="text-lg font-bold">{formatTime(slot.hour, slot.minute)}</div>
                            <div className="text-xs mt-1">
                              {isFull ? 'Full (2/2)' : 
                               slot.bookingCount > 0 ? `Available (${slot.bookingCount}/2)` :
                               userHasOtherBooking ? 'Change to' : 'Available'}
                            </div>
                          </button>
                        );
                      })}
                    </div>
                  </div>
                )
              )}
            </div>
          </div>
        </div>
      );
    }

    if (modal.type === 'reschedule') {
      const { currentTime, date } = modal.data;
      
      return (
        <div {...commonModalProps}>
          <div className="bg-white rounded-3xl shadow-2xl w-full max-w-md overflow-hidden animate-scale-in">
            <div className="p-8 text-center">
              <div className="w-16 h-16 bg-amber-100 rounded-full mx-auto mb-6 flex items-center justify-center">
                <Clock className="w-8 h-8 text-amber-600" />
              </div>
              <h3 className="text-xl font-bold text-gray-900 mb-3">Existing Appointment</h3>
              <p className="text-gray-600 mb-2">
                You have an appointment on{' '}
                <span className="font-semibold">
                  {date.toLocaleDateString('en-US', { 
                    weekday: 'long', month: 'long', day: 'numeric'
                  })}
                </span>
              </p>
              <p className="text-gray-600 mb-8">
                at <span className="font-semibold text-blue-600">{currentTime}</span>
              </p>
              <div className="flex flex-col gap-3">
                <button
                  onClick={async () => {
                    // Show available slots for rescheduling
                    const slots = await getAvailableSlots(date);
                    if (Array.isArray(slots) && slots.some(s => s.isAvailable)) {
                      setModal({ 
                        type: 'book', 
                        data: { date, slots, userHasOtherBooking: true } 
                      });
                    } else {
                      toast.error('No other available time slots on this day');
                    }
                  }}
                  className="bg-blue-500 hover:bg-blue-600 text-white py-4 rounded-2xl font-semibold transition-colors"
                >
                  Reschedule to Different Time
                </button>
                <button
                  onClick={cancelAppointment}
                  className="bg-red-500 hover:bg-red-600 text-white py-4 rounded-2xl font-semibold transition-colors"
                >
                  Cancel Appointment
                </button>
                <button
                  onClick={() => setModal({ type: null, data: null })}
                  className="bg-gray-100 hover:bg-gray-200 text-gray-700 py-3 rounded-2xl font-semibold transition-colors"
                >
                  Keep Current Appointment
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    if (modal.type === 'cancel') {
      return (
        <div {...commonModalProps}>
          <div className="bg-white rounded-3xl shadow-2xl w-full max-w-md overflow-hidden animate-scale-in">
            <div className="p-8 text-center">
              <div className="w-16 h-16 bg-red-100 rounded-full mx-auto mb-6 flex items-center justify-center">
                <X className="w-8 h-8 text-red-600" />
              </div>
              <h3 className="text-xl font-bold text-gray-900 mb-3">Cancel Appointment?</h3>
              <p className="text-gray-600 mb-8">This action cannot be undone</p>
              <div className="flex gap-4">
                <button
                  onClick={cancelAppointment}
                  className="flex-1 bg-red-500 hover:bg-red-600 text-white py-4 rounded-2xl font-semibold transition-colors"
                >
                  Cancel Appointment
                </button>
                <button
                  onClick={() => setModal({ type: null, data: null })}
                  className="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 py-4 rounded-2xl font-semibold transition-colors"
                >
                  Keep
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    return null;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-100">
      <style>
        {`
          .fc-day-today { background: #f0f9ff !important; }
          .fc-day-past { opacity: 0.6; }
          .fc-day-future:hover { background: #f8fafc; }
          .fc-event { border-radius: 8px !important; font-weight: 500; }
          .fc-toolbar-title { font-size: 1.5rem !important; font-weight: 700 !important; color: #1e293b; }
          .fc-button { border-radius: 12px !important; }
          .fc-button-primary { background: #3b82f6 !important; border: none !important; }
          .fc-button-primary:hover { background: #2563eb !important; }
          
          @keyframes scale-in {
            from { transform: scale(0.9); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
          }
          .animate-scale-in { animation: scale-in 0.2s ease-out; }
        `}
      </style>

      {/* Header */}
      <div className="bg-white border-b border-gray-100">
        <div className="max-w-4xl mx-auto px-6 py-6">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-2xl flex items-center justify-center">
              <Calendar className="w-6 h-6 text-white" />
            </div>
            <div>
              <h1 className="text-2xl font-bold text-gray-900">Book Appointment</h1>
              <p className="text-gray-600">{clinicInfo?.name || 'Select your preferred time'}</p>
            </div>
          </div>
        </div>
      </div>
      
      {/* Calendar */}
      <div className="max-w-4xl mx-auto px-6 py-8">
        <div className="bg-white rounded-3xl shadow-xl border border-gray-100 overflow-hidden">
          <div className="p-8">
            {loading ? (
              <div className="flex items-center justify-center py-20">
                <div className="w-8 h-8 border-3 border-blue-200 border-t-blue-600 rounded-full animate-spin"></div>
                <span className="ml-3 text-gray-600">Loading calendar...</span>
              </div>
            ) : (
              <FullCalendar
                plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin]}
                headerToolbar={{
                  left: 'prev',
                  center: 'title',
                  right: 'next'
                }}
                initialView="dayGridMonth"
                selectable={true}
                events={events}
                select={handleDateSelect}
                eventClick={handleEventClick}
                height="auto"
                selectConstraint={{
                  start: new Date(),
                  end: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000)
                }}
                dayCellDidMount={(arg) => {
                  const now = new Date();
                  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                  const maxDate = new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000);
                  const cellDate = new Date(arg.date.getFullYear(), arg.date.getMonth(), arg.date.getDate());
                  
                  // Only allow today and next 14 days
                  if (cellDate < today || cellDate > maxDate) {
                    arg.el.style.opacity = '0.3';
                    arg.el.style.pointerEvents = 'none';
                    arg.el.style.cursor = 'not-allowed';
                  } else {
                    // Check if within business hours (basic check)
                    if (businessHours) {
                      const weekdays = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
                      const dayConfig = businessHours[weekdays[cellDate.getDay()]];
                      
                      if (!dayConfig || dayConfig.closed) {
                        arg.el.style.opacity = '0.5';
                        arg.el.style.backgroundColor = '#f3f4f6';
                        arg.el.title = 'Clinic closed';
                      } else {
                        arg.el.style.cursor = 'pointer';
                        arg.el.title = 'Click to book appointment';
                      }
                    } else {
                      arg.el.style.cursor = 'pointer';
                    }
                  }
                }}
              />
            )}
          </div>
        </div>
      </div>

      {/* Modal */}
      {renderModal()}
    </div>
  );
}